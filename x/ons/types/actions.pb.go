// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: ollo/ons/v1beta1/actions.proto

package types

import (
	fmt "fmt"
	_ "github.com/gogo/protobuf/gogoproto"
	proto "github.com/gogo/protobuf/proto"
	github_com_gogo_protobuf_types "github.com/gogo/protobuf/types"
	_ "google.golang.org/protobuf/types/known/timestamppb"
	io "io"
	math "math"
	math_bits "math/bits"
	time "time"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf
var _ = time.Kitchen

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion3 // please upgrade the proto package

type OrderStatus int32

const (
	ORDER_STATUS_UNKNOWN     OrderStatus = 0
	ORDER_STATUS_QUEUED      OrderStatus = 1
	ORDER_STATUS_SUCCESS     OrderStatus = 2
	ORDER_STATUS_FAIL        OrderStatus = 3
	ORDER_STATUS_CANCELLED   OrderStatus = 4
	ORDER_STATUS_INVALID     OrderStatus = 5
	ORDER_STATUS_RESCHEDULED OrderStatus = 6
	ORDER_STATUS_PENDING     OrderStatus = 7
)

var OrderStatus_name = map[int32]string{
	0: "ORDER_STATUS_UNKNOWN",
	1: "ORDER_STATUS_QUEUED",
	2: "ORDER_STATUS_SUCCESS",
	3: "ORDER_STATUS_FAIL",
	4: "ORDER_STATUS_CANCELLED",
	5: "ORDER_STATUS_INVALID",
	6: "ORDER_STATUS_RESCHEDULED",
	7: "ORDER_STATUS_PENDING",
}

var OrderStatus_value = map[string]int32{
	"ORDER_STATUS_UNKNOWN":     0,
	"ORDER_STATUS_QUEUED":      1,
	"ORDER_STATUS_SUCCESS":     2,
	"ORDER_STATUS_FAIL":        3,
	"ORDER_STATUS_CANCELLED":   4,
	"ORDER_STATUS_INVALID":     5,
	"ORDER_STATUS_RESCHEDULED": 6,
	"ORDER_STATUS_PENDING":     7,
}

func (x OrderStatus) String() string {
	return proto.EnumName(OrderStatus_name, int32(x))
}

func (OrderStatus) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_978a97d7e2573696, []int{0}
}

type ActionStatus int32

const (
	ACTION_STATUS_UNKNOWN     ActionStatus = 0
	ACTION_STATUS_QUEUED      ActionStatus = 1
	ACTION_STATUS_SUCCESS     ActionStatus = 2
	ACTION_STATUS_FAIL        ActionStatus = 3
	ACTION_STATUS_CANCELLED   ActionStatus = 4
	ACTION_STATUS_INVALID     ActionStatus = 5
	ACTION_STATUS_RESCHEDULED ActionStatus = 6
	ACTION_STATUS_PENDING     ActionStatus = 7
)

var ActionStatus_name = map[int32]string{
	0: "ACTION_STATUS_UNKNOWN",
	1: "ACTION_STATUS_QUEUED",
	2: "ACTION_STATUS_SUCCESS",
	3: "ACTION_STATUS_FAIL",
	4: "ACTION_STATUS_CANCELLED",
	5: "ACTION_STATUS_INVALID",
	6: "ACTION_STATUS_RESCHEDULED",
	7: "ACTION_STATUS_PENDING",
}

var ActionStatus_value = map[string]int32{
	"ACTION_STATUS_UNKNOWN":     0,
	"ACTION_STATUS_QUEUED":      1,
	"ACTION_STATUS_SUCCESS":     2,
	"ACTION_STATUS_FAIL":        3,
	"ACTION_STATUS_CANCELLED":   4,
	"ACTION_STATUS_INVALID":     5,
	"ACTION_STATUS_RESCHEDULED": 6,
	"ACTION_STATUS_PENDING":     7,
}

func (x ActionStatus) String() string {
	return proto.EnumName(ActionStatus_name, int32(x))
}

func (ActionStatus) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_978a97d7e2573696, []int{1}
}

type ActionType int32

const (
	ACTION_TYPE_MUTE_NAME            ActionType = 0
	ACTION_TYPE_REPORT_NAME          ActionType = 1
	ACTION_TYPE_MESSAGE_NAME         ActionType = 2
	ACTION_TYPE_INVITE_GROUP_NAME    ActionType = 3
	ACTION_TYPE_FOLLOW_NAME          ActionType = 4
	ACTION_TYPE_TRADE_FOLLOW_NAME    ActionType = 5
	ACTION_TYPE_REQUEST_ORDER        ActionType = 6
	ACTION_TYPE_UNFOLLOW_NAME        ActionType = 7
	ACTION_TYPE_UNMUTE_NAME          ActionType = 8
	ACTION_TYPE_UNTAG_NAME           ActionType = 9
	ACTION_TYPE_CANCEL_REQUEST_ORDER ActionType = 10
)

var ActionType_name = map[int32]string{
	0:  "ACTION_TYPE_MUTE_NAME",
	1:  "ACTION_TYPE_REPORT_NAME",
	2:  "ACTION_TYPE_MESSAGE_NAME",
	3:  "ACTION_TYPE_INVITE_GROUP_NAME",
	4:  "ACTION_TYPE_FOLLOW_NAME",
	5:  "ACTION_TYPE_TRADE_FOLLOW_NAME",
	6:  "ACTION_TYPE_REQUEST_ORDER",
	7:  "ACTION_TYPE_UNFOLLOW_NAME",
	8:  "ACTION_TYPE_UNMUTE_NAME",
	9:  "ACTION_TYPE_UNTAG_NAME",
	10: "ACTION_TYPE_CANCEL_REQUEST_ORDER",
}

var ActionType_value = map[string]int32{
	"ACTION_TYPE_MUTE_NAME":            0,
	"ACTION_TYPE_REPORT_NAME":          1,
	"ACTION_TYPE_MESSAGE_NAME":         2,
	"ACTION_TYPE_INVITE_GROUP_NAME":    3,
	"ACTION_TYPE_FOLLOW_NAME":          4,
	"ACTION_TYPE_TRADE_FOLLOW_NAME":    5,
	"ACTION_TYPE_REQUEST_ORDER":        6,
	"ACTION_TYPE_UNFOLLOW_NAME":        7,
	"ACTION_TYPE_UNMUTE_NAME":          8,
	"ACTION_TYPE_UNTAG_NAME":           9,
	"ACTION_TYPE_CANCEL_REQUEST_ORDER": 10,
}

func (x ActionType) String() string {
	return proto.EnumName(ActionType_name, int32(x))
}

func (ActionType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_978a97d7e2573696, []int{2}
}

type CopyTradeType int32

const (
	COPY_TRADE_ALL_SWAPS_BY_RATIO             CopyTradeType = 0
	COPY_TRADE_NEW_DENOM_SWAPS_BY_RATIO       CopyTradeType = 1
	COPY_TRADE_DELEGATIONS_BY_RATIO           CopyTradeType = 2
	COPY_TRADE_ALL_STAKING_BY_RATIO           CopyTradeType = 3
	COPY_TRADE_FIAT_OFFRAMP_SALES_BY_RATIO    CopyTradeType = 4
	COPY_TRADE_FIAT_ONRAMP_PURCHASES_BY_RATIO CopyTradeType = 5
)

var CopyTradeType_name = map[int32]string{
	0: "COPY_TRADE_ALL_SWAPS_BY_RATIO",
	1: "COPY_TRADE_NEW_DENOM_SWAPS_BY_RATIO",
	2: "COPY_TRADE_DELEGATIONS_BY_RATIO",
	3: "COPY_TRADE_ALL_STAKING_BY_RATIO",
	4: "COPY_TRADE_FIAT_OFFRAMP_SALES_BY_RATIO",
	5: "COPY_TRADE_FIAT_ONRAMP_PURCHASES_BY_RATIO",
}

var CopyTradeType_value = map[string]int32{
	"COPY_TRADE_ALL_SWAPS_BY_RATIO":             0,
	"COPY_TRADE_NEW_DENOM_SWAPS_BY_RATIO":       1,
	"COPY_TRADE_DELEGATIONS_BY_RATIO":           2,
	"COPY_TRADE_ALL_STAKING_BY_RATIO":           3,
	"COPY_TRADE_FIAT_OFFRAMP_SALES_BY_RATIO":    4,
	"COPY_TRADE_FIAT_ONRAMP_PURCHASES_BY_RATIO": 5,
}

func (x CopyTradeType) String() string {
	return proto.EnumName(CopyTradeType_name, int32(x))
}

func (CopyTradeType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_978a97d7e2573696, []int{3}
}

type OrderType int32

const (
	ORDER_TYPE_UNSPECIFIED OrderType = 0
	ORDER_TYPE_SELL        OrderType = 1
	ORDER_TYPE_BUY         OrderType = 2
	ORDER_TYPE_LOAN        OrderType = 3
	ORDER_TYPE_GIVE        OrderType = 4
	ORDER_TYPE_REPORT      OrderType = 5
)

var OrderType_name = map[int32]string{
	0: "ORDER_TYPE_UNSPECIFIED",
	1: "ORDER_TYPE_SELL",
	2: "ORDER_TYPE_BUY",
	3: "ORDER_TYPE_LOAN",
	4: "ORDER_TYPE_GIVE",
	5: "ORDER_TYPE_REPORT",
}

var OrderType_value = map[string]int32{
	"ORDER_TYPE_UNSPECIFIED": 0,
	"ORDER_TYPE_SELL":        1,
	"ORDER_TYPE_BUY":         2,
	"ORDER_TYPE_LOAN":        3,
	"ORDER_TYPE_GIVE":        4,
	"ORDER_TYPE_REPORT":      5,
}

func (x OrderType) String() string {
	return proto.EnumName(OrderType_name, int32(x))
}

func (OrderType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_978a97d7e2573696, []int{4}
}

type ActionInfo struct {
	Id          uint64       `protobuf:"varint,1,opt,name=id,proto3" json:"id,omitempty"`
	ActionId    uint64       `protobuf:"varint,2,opt,name=action_id,json=actionId,proto3" json:"action_id,omitempty"`
	Name        string       `protobuf:"bytes,3,opt,name=name,proto3" json:"name,omitempty"`
	Type        ActionType   `protobuf:"varint,4,opt,name=type,proto3,enum=ollo.ons.v1beta1.ActionType" json:"type,omitempty"`
	Status      ActionStatus `protobuf:"varint,5,opt,name=status,proto3,enum=ollo.ons.v1beta1.ActionStatus" json:"status,omitempty"`
	Info        *ActionInfo  `protobuf:"bytes,6,opt,name=info,proto3" json:"info,omitempty"`
	CreatorAddr string       `protobuf:"bytes,7,opt,name=creator_addr,json=creatorAddr,proto3" json:"creator_addr,omitempty"`
	Tags        []*ActionTag `protobuf:"bytes,8,rep,name=tags,proto3" json:"tags,omitempty"`
	CreatedAt   time.Time    `protobuf:"bytes,9,opt,name=created_at,json=createdAt,proto3,stdtime" json:"created_at"`
}

func (m *ActionInfo) Reset()         { *m = ActionInfo{} }
func (m *ActionInfo) String() string { return proto.CompactTextString(m) }
func (*ActionInfo) ProtoMessage()    {}
func (*ActionInfo) Descriptor() ([]byte, []int) {
	return fileDescriptor_978a97d7e2573696, []int{0}
}
func (m *ActionInfo) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ActionInfo) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ActionInfo.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ActionInfo) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ActionInfo.Merge(m, src)
}
func (m *ActionInfo) XXX_Size() int {
	return m.Size()
}
func (m *ActionInfo) XXX_DiscardUnknown() {
	xxx_messageInfo_ActionInfo.DiscardUnknown(m)
}

var xxx_messageInfo_ActionInfo proto.InternalMessageInfo

func (m *ActionInfo) GetId() uint64 {
	if m != nil {
		return m.Id
	}
	return 0
}

func (m *ActionInfo) GetActionId() uint64 {
	if m != nil {
		return m.ActionId
	}
	return 0
}

func (m *ActionInfo) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *ActionInfo) GetType() ActionType {
	if m != nil {
		return m.Type
	}
	return ACTION_TYPE_MUTE_NAME
}

func (m *ActionInfo) GetStatus() ActionStatus {
	if m != nil {
		return m.Status
	}
	return ACTION_STATUS_UNKNOWN
}

func (m *ActionInfo) GetInfo() *ActionInfo {
	if m != nil {
		return m.Info
	}
	return nil
}

func (m *ActionInfo) GetCreatorAddr() string {
	if m != nil {
		return m.CreatorAddr
	}
	return ""
}

func (m *ActionInfo) GetTags() []*ActionTag {
	if m != nil {
		return m.Tags
	}
	return nil
}

func (m *ActionInfo) GetCreatedAt() time.Time {
	if m != nil {
		return m.CreatedAt
	}
	return time.Time{}
}

type CancelNameAction struct {
	Id             uint64      `protobuf:"varint,1,opt,name=id,proto3" json:"id,omitempty"`
	Name           string      `protobuf:"bytes,2,opt,name=name,proto3" json:"name,omitempty"`
	CancelActionId uint64      `protobuf:"varint,3,opt,name=cancel_action_id,json=cancelActionId,proto3" json:"cancel_action_id,omitempty"`
	Reason         string      `protobuf:"bytes,4,opt,name=reason,proto3" json:"reason,omitempty"`
	Data           *ActionInfo `protobuf:"bytes,5,opt,name=data,proto3" json:"data,omitempty"`
}

func (m *CancelNameAction) Reset()         { *m = CancelNameAction{} }
func (m *CancelNameAction) String() string { return proto.CompactTextString(m) }
func (*CancelNameAction) ProtoMessage()    {}
func (*CancelNameAction) Descriptor() ([]byte, []int) {
	return fileDescriptor_978a97d7e2573696, []int{1}
}
func (m *CancelNameAction) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CancelNameAction) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CancelNameAction.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *CancelNameAction) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CancelNameAction.Merge(m, src)
}
func (m *CancelNameAction) XXX_Size() int {
	return m.Size()
}
func (m *CancelNameAction) XXX_DiscardUnknown() {
	xxx_messageInfo_CancelNameAction.DiscardUnknown(m)
}

var xxx_messageInfo_CancelNameAction proto.InternalMessageInfo

func (m *CancelNameAction) GetId() uint64 {
	if m != nil {
		return m.Id
	}
	return 0
}

func (m *CancelNameAction) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *CancelNameAction) GetCancelActionId() uint64 {
	if m != nil {
		return m.CancelActionId
	}
	return 0
}

func (m *CancelNameAction) GetReason() string {
	if m != nil {
		return m.Reason
	}
	return ""
}

func (m *CancelNameAction) GetData() *ActionInfo {
	if m != nil {
		return m.Data
	}
	return nil
}

type RequestOrderName struct {
	Id        uint64      `protobuf:"varint,1,opt,name=id,proto3" json:"id,omitempty"`
	OrderType OrderType   `protobuf:"varint,2,opt,name=order_type,json=orderType,proto3,enum=ollo.ons.v1beta1.OrderType" json:"order_type,omitempty"`
	Reason    string      `protobuf:"bytes,3,opt,name=reason,proto3" json:"reason,omitempty"`
	Data      *ActionInfo `protobuf:"bytes,4,opt,name=data,proto3" json:"data,omitempty"`
}

func (m *RequestOrderName) Reset()         { *m = RequestOrderName{} }
func (m *RequestOrderName) String() string { return proto.CompactTextString(m) }
func (*RequestOrderName) ProtoMessage()    {}
func (*RequestOrderName) Descriptor() ([]byte, []int) {
	return fileDescriptor_978a97d7e2573696, []int{2}
}
func (m *RequestOrderName) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *RequestOrderName) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_RequestOrderName.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *RequestOrderName) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RequestOrderName.Merge(m, src)
}
func (m *RequestOrderName) XXX_Size() int {
	return m.Size()
}
func (m *RequestOrderName) XXX_DiscardUnknown() {
	xxx_messageInfo_RequestOrderName.DiscardUnknown(m)
}

var xxx_messageInfo_RequestOrderName proto.InternalMessageInfo

func (m *RequestOrderName) GetId() uint64 {
	if m != nil {
		return m.Id
	}
	return 0
}

func (m *RequestOrderName) GetOrderType() OrderType {
	if m != nil {
		return m.OrderType
	}
	return ORDER_TYPE_UNSPECIFIED
}

func (m *RequestOrderName) GetReason() string {
	if m != nil {
		return m.Reason
	}
	return ""
}

func (m *RequestOrderName) GetData() *ActionInfo {
	if m != nil {
		return m.Data
	}
	return nil
}

type MuteName struct {
	Id     uint64      `protobuf:"varint,1,opt,name=id,proto3" json:"id,omitempty"`
	Reason string      `protobuf:"bytes,2,opt,name=reason,proto3" json:"reason,omitempty"`
	Block  bool        `protobuf:"varint,3,opt,name=block,proto3" json:"block,omitempty"`
	Data   *ActionInfo `protobuf:"bytes,4,opt,name=data,proto3" json:"data,omitempty"`
}

func (m *MuteName) Reset()         { *m = MuteName{} }
func (m *MuteName) String() string { return proto.CompactTextString(m) }
func (*MuteName) ProtoMessage()    {}
func (*MuteName) Descriptor() ([]byte, []int) {
	return fileDescriptor_978a97d7e2573696, []int{3}
}
func (m *MuteName) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MuteName) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MuteName.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MuteName) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MuteName.Merge(m, src)
}
func (m *MuteName) XXX_Size() int {
	return m.Size()
}
func (m *MuteName) XXX_DiscardUnknown() {
	xxx_messageInfo_MuteName.DiscardUnknown(m)
}

var xxx_messageInfo_MuteName proto.InternalMessageInfo

func (m *MuteName) GetId() uint64 {
	if m != nil {
		return m.Id
	}
	return 0
}

func (m *MuteName) GetReason() string {
	if m != nil {
		return m.Reason
	}
	return ""
}

func (m *MuteName) GetBlock() bool {
	if m != nil {
		return m.Block
	}
	return false
}

func (m *MuteName) GetData() *ActionInfo {
	if m != nil {
		return m.Data
	}
	return nil
}

type ReportName struct {
	Id     uint64      `protobuf:"varint,1,opt,name=id,proto3" json:"id,omitempty"`
	Reason string      `protobuf:"bytes,2,opt,name=reason,proto3" json:"reason,omitempty"`
	Mute   bool        `protobuf:"varint,3,opt,name=mute,proto3" json:"mute,omitempty"`
	Data   *ActionInfo `protobuf:"bytes,4,opt,name=data,proto3" json:"data,omitempty"`
}

func (m *ReportName) Reset()         { *m = ReportName{} }
func (m *ReportName) String() string { return proto.CompactTextString(m) }
func (*ReportName) ProtoMessage()    {}
func (*ReportName) Descriptor() ([]byte, []int) {
	return fileDescriptor_978a97d7e2573696, []int{4}
}
func (m *ReportName) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ReportName) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ReportName.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ReportName) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ReportName.Merge(m, src)
}
func (m *ReportName) XXX_Size() int {
	return m.Size()
}
func (m *ReportName) XXX_DiscardUnknown() {
	xxx_messageInfo_ReportName.DiscardUnknown(m)
}

var xxx_messageInfo_ReportName proto.InternalMessageInfo

func (m *ReportName) GetId() uint64 {
	if m != nil {
		return m.Id
	}
	return 0
}

func (m *ReportName) GetReason() string {
	if m != nil {
		return m.Reason
	}
	return ""
}

func (m *ReportName) GetMute() bool {
	if m != nil {
		return m.Mute
	}
	return false
}

func (m *ReportName) GetData() *ActionInfo {
	if m != nil {
		return m.Data
	}
	return nil
}

type InviteName struct {
	Id      uint64      `protobuf:"varint,1,opt,name=id,proto3" json:"id,omitempty"`
	Title   string      `protobuf:"bytes,2,opt,name=title,proto3" json:"title,omitempty"`
	Content string      `protobuf:"bytes,3,opt,name=content,proto3" json:"content,omitempty"`
	GroupId uint64      `protobuf:"varint,4,opt,name=group_id,json=groupId,proto3" json:"group_id,omitempty"`
	Data    *ActionInfo `protobuf:"bytes,5,opt,name=data,proto3" json:"data,omitempty"`
}

func (m *InviteName) Reset()         { *m = InviteName{} }
func (m *InviteName) String() string { return proto.CompactTextString(m) }
func (*InviteName) ProtoMessage()    {}
func (*InviteName) Descriptor() ([]byte, []int) {
	return fileDescriptor_978a97d7e2573696, []int{5}
}
func (m *InviteName) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *InviteName) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_InviteName.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *InviteName) XXX_Merge(src proto.Message) {
	xxx_messageInfo_InviteName.Merge(m, src)
}
func (m *InviteName) XXX_Size() int {
	return m.Size()
}
func (m *InviteName) XXX_DiscardUnknown() {
	xxx_messageInfo_InviteName.DiscardUnknown(m)
}

var xxx_messageInfo_InviteName proto.InternalMessageInfo

func (m *InviteName) GetId() uint64 {
	if m != nil {
		return m.Id
	}
	return 0
}

func (m *InviteName) GetTitle() string {
	if m != nil {
		return m.Title
	}
	return ""
}

func (m *InviteName) GetContent() string {
	if m != nil {
		return m.Content
	}
	return ""
}

func (m *InviteName) GetGroupId() uint64 {
	if m != nil {
		return m.GroupId
	}
	return 0
}

func (m *InviteName) GetData() *ActionInfo {
	if m != nil {
		return m.Data
	}
	return nil
}

type MessageName struct {
	Id      uint64      `protobuf:"varint,1,opt,name=id,proto3" json:"id,omitempty"`
	Title   string      `protobuf:"bytes,2,opt,name=title,proto3" json:"title,omitempty"`
	Content string      `protobuf:"bytes,3,opt,name=content,proto3" json:"content,omitempty"`
	Data    *ActionInfo `protobuf:"bytes,4,opt,name=data,proto3" json:"data,omitempty"`
}

func (m *MessageName) Reset()         { *m = MessageName{} }
func (m *MessageName) String() string { return proto.CompactTextString(m) }
func (*MessageName) ProtoMessage()    {}
func (*MessageName) Descriptor() ([]byte, []int) {
	return fileDescriptor_978a97d7e2573696, []int{6}
}
func (m *MessageName) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MessageName) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MessageName.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MessageName) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MessageName.Merge(m, src)
}
func (m *MessageName) XXX_Size() int {
	return m.Size()
}
func (m *MessageName) XXX_DiscardUnknown() {
	xxx_messageInfo_MessageName.DiscardUnknown(m)
}

var xxx_messageInfo_MessageName proto.InternalMessageInfo

func (m *MessageName) GetId() uint64 {
	if m != nil {
		return m.Id
	}
	return 0
}

func (m *MessageName) GetTitle() string {
	if m != nil {
		return m.Title
	}
	return ""
}

func (m *MessageName) GetContent() string {
	if m != nil {
		return m.Content
	}
	return ""
}

func (m *MessageName) GetData() *ActionInfo {
	if m != nil {
		return m.Data
	}
	return nil
}

type TagName struct {
	Id      uint64      `protobuf:"varint,1,opt,name=id,proto3" json:"id,omitempty"`
	Tags    []*NameTag  `protobuf:"bytes,2,rep,name=tags,proto3" json:"tags,omitempty"`
	Message string      `protobuf:"bytes,3,opt,name=message,proto3" json:"message,omitempty"`
	Follow  bool        `protobuf:"varint,4,opt,name=follow,proto3" json:"follow,omitempty"`
	Data    *ActionInfo `protobuf:"bytes,5,opt,name=data,proto3" json:"data,omitempty"`
}

func (m *TagName) Reset()         { *m = TagName{} }
func (m *TagName) String() string { return proto.CompactTextString(m) }
func (*TagName) ProtoMessage()    {}
func (*TagName) Descriptor() ([]byte, []int) {
	return fileDescriptor_978a97d7e2573696, []int{7}
}
func (m *TagName) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TagName) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_TagName.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *TagName) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TagName.Merge(m, src)
}
func (m *TagName) XXX_Size() int {
	return m.Size()
}
func (m *TagName) XXX_DiscardUnknown() {
	xxx_messageInfo_TagName.DiscardUnknown(m)
}

var xxx_messageInfo_TagName proto.InternalMessageInfo

func (m *TagName) GetId() uint64 {
	if m != nil {
		return m.Id
	}
	return 0
}

func (m *TagName) GetTags() []*NameTag {
	if m != nil {
		return m.Tags
	}
	return nil
}

func (m *TagName) GetMessage() string {
	if m != nil {
		return m.Message
	}
	return ""
}

func (m *TagName) GetFollow() bool {
	if m != nil {
		return m.Follow
	}
	return false
}

func (m *TagName) GetData() *ActionInfo {
	if m != nil {
		return m.Data
	}
	return nil
}

type FollowName struct {
	Id          uint64      `protobuf:"varint,1,opt,name=id,proto3" json:"id,omitempty"`
	Message     string      `protobuf:"bytes,2,opt,name=message,proto3" json:"message,omitempty"`
	TradeFollow bool        `protobuf:"varint,3,opt,name=trade_follow,json=tradeFollow,proto3" json:"trade_follow,omitempty"`
	Data        *ActionInfo `protobuf:"bytes,4,opt,name=data,proto3" json:"data,omitempty"`
}

func (m *FollowName) Reset()         { *m = FollowName{} }
func (m *FollowName) String() string { return proto.CompactTextString(m) }
func (*FollowName) ProtoMessage()    {}
func (*FollowName) Descriptor() ([]byte, []int) {
	return fileDescriptor_978a97d7e2573696, []int{8}
}
func (m *FollowName) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *FollowName) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_FollowName.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *FollowName) XXX_Merge(src proto.Message) {
	xxx_messageInfo_FollowName.Merge(m, src)
}
func (m *FollowName) XXX_Size() int {
	return m.Size()
}
func (m *FollowName) XXX_DiscardUnknown() {
	xxx_messageInfo_FollowName.DiscardUnknown(m)
}

var xxx_messageInfo_FollowName proto.InternalMessageInfo

func (m *FollowName) GetId() uint64 {
	if m != nil {
		return m.Id
	}
	return 0
}

func (m *FollowName) GetMessage() string {
	if m != nil {
		return m.Message
	}
	return ""
}

func (m *FollowName) GetTradeFollow() bool {
	if m != nil {
		return m.TradeFollow
	}
	return false
}

func (m *FollowName) GetData() *ActionInfo {
	if m != nil {
		return m.Data
	}
	return nil
}

type TradeFollowName struct {
	Id         uint64      `protobuf:"varint,1,opt,name=id,proto3" json:"id,omitempty"`
	CopyTrades bool        `protobuf:"varint,2,opt,name=copy_trades,json=copyTrades,proto3" json:"copy_trades,omitempty"`
	Message    string      `protobuf:"bytes,3,opt,name=message,proto3" json:"message,omitempty"`
	Data       *ActionInfo `protobuf:"bytes,4,opt,name=data,proto3" json:"data,omitempty"`
}

func (m *TradeFollowName) Reset()         { *m = TradeFollowName{} }
func (m *TradeFollowName) String() string { return proto.CompactTextString(m) }
func (*TradeFollowName) ProtoMessage()    {}
func (*TradeFollowName) Descriptor() ([]byte, []int) {
	return fileDescriptor_978a97d7e2573696, []int{9}
}
func (m *TradeFollowName) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TradeFollowName) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_TradeFollowName.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *TradeFollowName) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TradeFollowName.Merge(m, src)
}
func (m *TradeFollowName) XXX_Size() int {
	return m.Size()
}
func (m *TradeFollowName) XXX_DiscardUnknown() {
	xxx_messageInfo_TradeFollowName.DiscardUnknown(m)
}

var xxx_messageInfo_TradeFollowName proto.InternalMessageInfo

func (m *TradeFollowName) GetId() uint64 {
	if m != nil {
		return m.Id
	}
	return 0
}

func (m *TradeFollowName) GetCopyTrades() bool {
	if m != nil {
		return m.CopyTrades
	}
	return false
}

func (m *TradeFollowName) GetMessage() string {
	if m != nil {
		return m.Message
	}
	return ""
}

func (m *TradeFollowName) GetData() *ActionInfo {
	if m != nil {
		return m.Data
	}
	return nil
}

type CopyTradeName struct {
	Id              uint64        `protobuf:"varint,1,opt,name=id,proto3" json:"id,omitempty"`
	CopyTradeParams string        `protobuf:"bytes,2,opt,name=copy_trade_params,json=copyTradeParams,proto3" json:"copy_trade_params,omitempty"`
	Message         string        `protobuf:"bytes,3,opt,name=message,proto3" json:"message,omitempty"`
	CopyTradeType   CopyTradeType `protobuf:"varint,4,opt,name=copy_trade_type,json=copyTradeType,proto3,enum=ollo.ons.v1beta1.CopyTradeType" json:"copy_trade_type,omitempty"`
	Data            *ActionInfo   `protobuf:"bytes,5,opt,name=data,proto3" json:"data,omitempty"`
}

func (m *CopyTradeName) Reset()         { *m = CopyTradeName{} }
func (m *CopyTradeName) String() string { return proto.CompactTextString(m) }
func (*CopyTradeName) ProtoMessage()    {}
func (*CopyTradeName) Descriptor() ([]byte, []int) {
	return fileDescriptor_978a97d7e2573696, []int{10}
}
func (m *CopyTradeName) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CopyTradeName) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CopyTradeName.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *CopyTradeName) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CopyTradeName.Merge(m, src)
}
func (m *CopyTradeName) XXX_Size() int {
	return m.Size()
}
func (m *CopyTradeName) XXX_DiscardUnknown() {
	xxx_messageInfo_CopyTradeName.DiscardUnknown(m)
}

var xxx_messageInfo_CopyTradeName proto.InternalMessageInfo

func (m *CopyTradeName) GetId() uint64 {
	if m != nil {
		return m.Id
	}
	return 0
}

func (m *CopyTradeName) GetCopyTradeParams() string {
	if m != nil {
		return m.CopyTradeParams
	}
	return ""
}

func (m *CopyTradeName) GetMessage() string {
	if m != nil {
		return m.Message
	}
	return ""
}

func (m *CopyTradeName) GetCopyTradeType() CopyTradeType {
	if m != nil {
		return m.CopyTradeType
	}
	return COPY_TRADE_ALL_SWAPS_BY_RATIO
}

func (m *CopyTradeName) GetData() *ActionInfo {
	if m != nil {
		return m.Data
	}
	return nil
}

type ActionTag struct {
	Tag         string     `protobuf:"bytes,1,opt,name=tag,proto3" json:"tag,omitempty"`
	ActionId    uint64     `protobuf:"varint,2,opt,name=action_id,json=actionId,proto3" json:"action_id,omitempty"`
	ActionType  ActionType `protobuf:"varint,3,opt,name=action_type,json=actionType,proto3,enum=ollo.ons.v1beta1.ActionType" json:"action_type,omitempty"`
	CreatorAddr string     `protobuf:"bytes,4,opt,name=creator_addr,json=creatorAddr,proto3" json:"creator_addr,omitempty"`
	Magnitude   uint32     `protobuf:"varint,5,opt,name=magnitude,proto3" json:"magnitude,omitempty"`
	TaggedAt    time.Time  `protobuf:"bytes,6,opt,name=tagged_at,json=taggedAt,proto3,stdtime" json:"tagged_at"`
}

func (m *ActionTag) Reset()         { *m = ActionTag{} }
func (m *ActionTag) String() string { return proto.CompactTextString(m) }
func (*ActionTag) ProtoMessage()    {}
func (*ActionTag) Descriptor() ([]byte, []int) {
	return fileDescriptor_978a97d7e2573696, []int{11}
}
func (m *ActionTag) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ActionTag) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ActionTag.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ActionTag) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ActionTag.Merge(m, src)
}
func (m *ActionTag) XXX_Size() int {
	return m.Size()
}
func (m *ActionTag) XXX_DiscardUnknown() {
	xxx_messageInfo_ActionTag.DiscardUnknown(m)
}

var xxx_messageInfo_ActionTag proto.InternalMessageInfo

func (m *ActionTag) GetTag() string {
	if m != nil {
		return m.Tag
	}
	return ""
}

func (m *ActionTag) GetActionId() uint64 {
	if m != nil {
		return m.ActionId
	}
	return 0
}

func (m *ActionTag) GetActionType() ActionType {
	if m != nil {
		return m.ActionType
	}
	return ACTION_TYPE_MUTE_NAME
}

func (m *ActionTag) GetCreatorAddr() string {
	if m != nil {
		return m.CreatorAddr
	}
	return ""
}

func (m *ActionTag) GetMagnitude() uint32 {
	if m != nil {
		return m.Magnitude
	}
	return 0
}

func (m *ActionTag) GetTaggedAt() time.Time {
	if m != nil {
		return m.TaggedAt
	}
	return time.Time{}
}

func init() {
	proto.RegisterEnum("ollo.ons.v1beta1.OrderStatus", OrderStatus_name, OrderStatus_value)
	proto.RegisterEnum("ollo.ons.v1beta1.ActionStatus", ActionStatus_name, ActionStatus_value)
	proto.RegisterEnum("ollo.ons.v1beta1.ActionType", ActionType_name, ActionType_value)
	proto.RegisterEnum("ollo.ons.v1beta1.CopyTradeType", CopyTradeType_name, CopyTradeType_value)
	proto.RegisterEnum("ollo.ons.v1beta1.OrderType", OrderType_name, OrderType_value)
	proto.RegisterType((*ActionInfo)(nil), "ollo.ons.v1beta1.ActionInfo")
	proto.RegisterType((*CancelNameAction)(nil), "ollo.ons.v1beta1.CancelNameAction")
	proto.RegisterType((*RequestOrderName)(nil), "ollo.ons.v1beta1.RequestOrderName")
	proto.RegisterType((*MuteName)(nil), "ollo.ons.v1beta1.MuteName")
	proto.RegisterType((*ReportName)(nil), "ollo.ons.v1beta1.ReportName")
	proto.RegisterType((*InviteName)(nil), "ollo.ons.v1beta1.InviteName")
	proto.RegisterType((*MessageName)(nil), "ollo.ons.v1beta1.MessageName")
	proto.RegisterType((*TagName)(nil), "ollo.ons.v1beta1.TagName")
	proto.RegisterType((*FollowName)(nil), "ollo.ons.v1beta1.FollowName")
	proto.RegisterType((*TradeFollowName)(nil), "ollo.ons.v1beta1.TradeFollowName")
	proto.RegisterType((*CopyTradeName)(nil), "ollo.ons.v1beta1.CopyTradeName")
	proto.RegisterType((*ActionTag)(nil), "ollo.ons.v1beta1.ActionTag")
}

func init() { proto.RegisterFile("ollo/ons/v1beta1/actions.proto", fileDescriptor_978a97d7e2573696) }

var fileDescriptor_978a97d7e2573696 = []byte{
	// 1348 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xac, 0x57, 0xcf, 0x6f, 0x1b, 0x45,
	0x14, 0xf6, 0xac, 0x1d, 0xff, 0x78, 0x6e, 0x93, 0xed, 0x34, 0x6d, 0x37, 0x49, 0x6b, 0xa7, 0x2d,
	0x82, 0x10, 0xa9, 0x36, 0x2d, 0x12, 0x87, 0x4a, 0x1c, 0x36, 0xf6, 0xda, 0x5d, 0xd5, 0x59, 0xbb,
	0xfb, 0xa3, 0x51, 0xb8, 0xac, 0x36, 0xde, 0xcd, 0xca, 0x22, 0xf6, 0x1a, 0xef, 0xb8, 0xd0, 0x1b,
	0x17, 0x44, 0xc5, 0xa9, 0x48, 0x1c, 0x90, 0x38, 0x50, 0x09, 0x0e, 0x9c, 0x10, 0xe2, 0xaf, 0xe8,
	0xb1, 0x47, 0x4e, 0x80, 0x5a, 0x09, 0x81, 0xc4, 0x89, 0xbf, 0x00, 0xed, 0xec, 0xda, 0x9e, 0xf5,
	0x3a, 0x81, 0x04, 0x6e, 0x33, 0xef, 0xfb, 0xde, 0x7b, 0xdf, 0x7b, 0xf3, 0x3c, 0xb3, 0x86, 0x92,
	0x77, 0x74, 0xe4, 0x55, 0xbd, 0x81, 0x5f, 0x7d, 0x74, 0xfb, 0xc0, 0x21, 0xd6, 0xed, 0xaa, 0xd5,
	0x25, 0x3d, 0x6f, 0xe0, 0x57, 0x86, 0x23, 0x8f, 0x78, 0x98, 0x0f, 0xf0, 0x4a, 0xb0, 0x8f, 0xf0,
	0xf5, 0x55, 0xd7, 0x73, 0x3d, 0x0a, 0x56, 0x83, 0x55, 0xc8, 0x5b, 0xdf, 0x48, 0xc4, 0x19, 0x58,
	0x7d, 0x27, 0x02, 0xcb, 0xae, 0xe7, 0xb9, 0x47, 0x4e, 0x95, 0xee, 0x0e, 0xc6, 0x87, 0x55, 0xd2,
	0xeb, 0x3b, 0x3e, 0xb1, 0xfa, 0xc3, 0x90, 0x70, 0xe3, 0x49, 0x1a, 0x40, 0xa4, 0x79, 0xe5, 0xc1,
	0xa1, 0x87, 0x97, 0x81, 0xeb, 0xd9, 0x02, 0xda, 0x44, 0x5b, 0x19, 0x95, 0xeb, 0xd9, 0x78, 0x03,
	0x0a, 0xa1, 0x2a, 0xb3, 0x67, 0x0b, 0x1c, 0x35, 0xe7, 0x43, 0x83, 0x6c, 0x63, 0x0c, 0x99, 0x20,
	0x95, 0x90, 0xde, 0x44, 0x5b, 0x05, 0x95, 0xae, 0xf1, 0x5b, 0x90, 0x21, 0x8f, 0x87, 0x8e, 0x90,
	0xd9, 0x44, 0x5b, 0xcb, 0x77, 0xae, 0x56, 0xe6, 0x8b, 0xa8, 0x84, 0xc9, 0xf4, 0xc7, 0x43, 0x47,
	0xa5, 0x4c, 0xfc, 0x0e, 0x64, 0x7d, 0x62, 0x91, 0xb1, 0x2f, 0x2c, 0x51, 0x9f, 0xd2, 0x71, 0x3e,
	0x1a, 0x65, 0xa9, 0x11, 0x3b, 0xc8, 0xd4, 0x1b, 0x1c, 0x7a, 0x42, 0x76, 0x13, 0x6d, 0x15, 0x8f,
	0xcf, 0x14, 0x94, 0xa5, 0x52, 0x26, 0xbe, 0x0e, 0xe7, 0xba, 0x23, 0xc7, 0x22, 0xde, 0xc8, 0xb4,
	0x6c, 0x7b, 0x24, 0xe4, 0xa8, 0xee, 0x62, 0x64, 0x13, 0x6d, 0x7b, 0x84, 0xab, 0x90, 0x21, 0x96,
	0xeb, 0x0b, 0xf9, 0xcd, 0xf4, 0x56, 0xf1, 0xce, 0xc6, 0xb1, 0xf2, 0x2d, 0x57, 0xa5, 0x44, 0x5c,
	0x03, 0xa0, 0xfe, 0x8e, 0x6d, 0x5a, 0x44, 0x28, 0x50, 0x2d, 0xeb, 0x95, 0xb0, 0xeb, 0x95, 0x49,
	0xd7, 0x2b, 0xfa, 0xa4, 0xeb, 0x3b, 0xf9, 0xe7, 0x3f, 0x97, 0x53, 0x4f, 0x7f, 0x29, 0x23, 0xb5,
	0x10, 0xf9, 0x89, 0xe4, 0x6e, 0xe6, 0xcb, 0x67, 0x65, 0x74, 0xe3, 0x07, 0x04, 0x7c, 0xcd, 0x1a,
	0x74, 0x9d, 0x23, 0xc5, 0xea, 0x3b, 0x61, 0xa2, 0xc4, 0x81, 0x4c, 0x7a, 0xce, 0x31, 0x3d, 0xdf,
	0x02, 0xbe, 0x4b, 0xfd, 0xcc, 0xd9, 0x59, 0xa5, 0xa9, 0xc7, 0x72, 0x68, 0x17, 0x27, 0x27, 0x76,
	0x19, 0xb2, 0x23, 0xc7, 0xf2, 0xbd, 0x01, 0x3d, 0x9f, 0x82, 0x1a, 0xed, 0x82, 0x5e, 0xda, 0x16,
	0xb1, 0xe8, 0x09, 0xfc, 0x63, 0x2f, 0x03, 0x66, 0x24, 0xf9, 0x7b, 0x04, 0xbc, 0xea, 0x7c, 0x30,
	0x76, 0x7c, 0xd2, 0x1e, 0xd9, 0xce, 0x28, 0x10, 0x9e, 0x90, 0x7c, 0x17, 0xc0, 0x0b, 0x40, 0x93,
	0x0e, 0x06, 0x47, 0x0f, 0x79, 0x41, 0x67, 0x69, 0x00, 0x3a, 0x17, 0x05, 0x6f, 0xb2, 0x64, 0x04,
	0xa7, 0x17, 0x0a, 0xce, 0x9c, 0x52, 0xf0, 0xc7, 0x08, 0xf2, 0xbb, 0x63, 0xe2, 0x2c, 0x14, 0x3a,
	0x4b, 0xc6, 0xc5, 0x92, 0xad, 0xc2, 0xd2, 0xc1, 0x91, 0xd7, 0x7d, 0x9f, 0x6a, 0xc8, 0xab, 0xe1,
	0xe6, 0xbf, 0x48, 0x00, 0xd5, 0x19, 0x7a, 0x23, 0x72, 0x2a, 0x11, 0x18, 0x32, 0xfd, 0x31, 0x71,
	0x22, 0x0d, 0x74, 0x7d, 0x66, 0x09, 0x5f, 0x23, 0x00, 0x79, 0xf0, 0xa8, 0x77, 0x4c, 0x1f, 0x56,
	0x61, 0x89, 0xf4, 0xc8, 0xd1, 0x64, 0xc8, 0xc2, 0x0d, 0x16, 0x20, 0xd7, 0xf5, 0x06, 0xc4, 0x19,
	0x90, 0xe8, 0x2c, 0x26, 0x5b, 0xbc, 0x06, 0x79, 0x77, 0xe4, 0x8d, 0x87, 0xc1, 0xdc, 0x65, 0x68,
	0x94, 0x1c, 0xdd, 0xcb, 0xf6, 0x99, 0x07, 0xeb, 0x13, 0x04, 0xc5, 0x5d, 0xc7, 0xf7, 0x2d, 0xf7,
	0xff, 0x91, 0x78, 0xd6, 0x4e, 0xfd, 0x88, 0x20, 0xa7, 0x5b, 0xee, 0x42, 0x0d, 0xb7, 0xa2, 0xbb,
	0x82, 0xa3, 0x77, 0xc5, 0x5a, 0x32, 0x66, 0xe0, 0x35, 0xbb, 0x29, 0x04, 0xc8, 0xf5, 0xc3, 0x8a,
	0x26, 0xe2, 0xa2, 0x6d, 0x70, 0xe4, 0x87, 0x81, 0xf3, 0x87, 0x54, 0x5e, 0x5e, 0x8d, 0x76, 0x67,
	0x6e, 0xde, 0xe7, 0x08, 0xa0, 0x41, 0x43, 0x2c, 0xd4, 0xcd, 0x08, 0xe1, 0xe2, 0x42, 0xae, 0xc3,
	0x39, 0x32, 0xb2, 0x6c, 0xc7, 0x8c, 0xe4, 0x84, 0xb3, 0x56, 0xa4, 0xb6, 0x46, 0x5c, 0xd3, 0x69,
	0x1b, 0xf9, 0x05, 0x82, 0x15, 0x7d, 0x16, 0x67, 0xa1, 0xb0, 0x32, 0x14, 0xbb, 0xde, 0xf0, 0xb1,
	0x49, 0xf3, 0xf9, 0x54, 0x5c, 0x5e, 0x85, 0xc0, 0x44, 0x3d, 0x4f, 0x6a, 0xe1, 0x59, 0x65, 0xfd,
	0x86, 0xe0, 0x7c, 0x6d, 0x92, 0x60, 0xa1, 0xa8, 0x6d, 0xb8, 0x30, 0x13, 0x65, 0x0e, 0xad, 0x91,
	0xd5, 0xf7, 0xa3, 0xbe, 0xad, 0x4c, 0xa5, 0x75, 0xa8, 0xf9, 0x04, 0x7d, 0x4d, 0x58, 0x61, 0xa2,
	0x30, 0x2f, 0x64, 0x39, 0x29, 0x75, 0xaa, 0x87, 0x5e, 0x86, 0xe7, 0xbb, 0xec, 0xf6, 0xcc, 0x33,
	0xf1, 0x29, 0x07, 0x85, 0xe9, 0xdb, 0x85, 0x79, 0x48, 0x13, 0xcb, 0xa5, 0x55, 0x16, 0xd4, 0x60,
	0x79, 0xf2, 0x43, 0xff, 0x2e, 0x14, 0x23, 0x90, 0x2a, 0x4f, 0xff, 0x8b, 0xb7, 0x1d, 0xac, 0xe9,
	0x3a, 0xf1, 0xee, 0x66, 0x92, 0xef, 0xee, 0x55, 0x28, 0xf4, 0x2d, 0x77, 0xd0, 0x23, 0x63, 0xdb,
	0xa1, 0xb5, 0x9d, 0x57, 0x67, 0x06, 0x2c, 0x42, 0x81, 0x58, 0xae, 0x1b, 0xbe, 0xb1, 0xd9, 0x53,
	0xbc, 0xb1, 0xf9, 0xd0, 0x4d, 0x24, 0x77, 0xf3, 0x41, 0x17, 0x7e, 0x7f, 0x56, 0x46, 0xdb, 0x7f,
	0x20, 0x28, 0xd2, 0xb7, 0x26, 0xfc, 0x9e, 0xc0, 0x02, 0xac, 0xb6, 0xd5, 0xba, 0xa4, 0x9a, 0x9a,
	0x2e, 0xea, 0x86, 0x66, 0x1a, 0xca, 0x7d, 0xa5, 0xbd, 0xa7, 0xf0, 0x29, 0x7c, 0x05, 0x2e, 0xc6,
	0x90, 0x07, 0x86, 0x64, 0x48, 0x75, 0x1e, 0x25, 0x5c, 0x34, 0xa3, 0x56, 0x93, 0x34, 0x8d, 0xe7,
	0xf0, 0x25, 0xb8, 0x10, 0x43, 0x1a, 0xa2, 0xdc, 0xe2, 0xd3, 0x78, 0x1d, 0x2e, 0xc7, 0xcc, 0x35,
	0x51, 0xa9, 0x49, 0xad, 0x96, 0x54, 0xe7, 0x33, 0x89, 0x60, 0xb2, 0xf2, 0x50, 0x6c, 0xc9, 0x75,
	0x7e, 0x09, 0x5f, 0x05, 0x21, 0x86, 0xa8, 0x92, 0x56, 0xbb, 0x27, 0xd5, 0x8d, 0xc0, 0x2f, 0x9b,
	0xf0, 0xeb, 0x48, 0x4a, 0x5d, 0x56, 0x9a, 0x7c, 0x6e, 0x3d, 0xff, 0xe4, 0x9b, 0x52, 0xea, 0xbb,
	0x6f, 0x4b, 0x68, 0xfb, 0x2f, 0x04, 0xe7, 0xd8, 0x8f, 0x27, 0xbc, 0x06, 0x97, 0xc4, 0x9a, 0x2e,
	0xb7, 0x95, 0x64, 0xb5, 0x02, 0xac, 0xc6, 0xa1, 0x69, 0xb9, 0x09, 0xa7, 0x59, 0xbd, 0x97, 0x01,
	0xc7, 0xa1, 0xa8, 0xe0, 0x0d, 0xb8, 0x12, 0xb7, 0xb3, 0x15, 0x27, 0xe2, 0xcd, 0x4a, 0xbe, 0x06,
	0x6b, 0x71, 0x28, 0x5e, 0x73, 0xc2, 0x73, 0x51, 0xd1, 0x7f, 0x72, 0x93, 0x4f, 0x5a, 0x3a, 0x7d,
	0x33, 0x1f, 0x7d, 0xbf, 0x23, 0x99, 0xbb, 0x86, 0x2e, 0x99, 0x8a, 0xb8, 0x2b, 0xf1, 0x29, 0x46,
	0x25, 0x85, 0x54, 0xa9, 0xd3, 0x56, 0xf5, 0x10, 0x44, 0x41, 0xf7, 0x63, 0x7e, 0x92, 0xa6, 0x89,
	0xcd, 0xc8, 0x95, 0xc3, 0xd7, 0xe1, 0x1a, 0x8b, 0xca, 0xca, 0x43, 0x59, 0x97, 0xcc, 0xa6, 0xda,
	0x36, 0x3a, 0x21, 0x25, 0x3d, 0x1f, 0xbd, 0xd1, 0x6e, 0xb5, 0xda, 0x7b, 0x21, 0x98, 0x99, 0xf7,
	0xd7, 0x55, 0xb1, 0x1e, 0xa7, 0xb0, 0xbd, 0x88, 0xd4, 0x3d, 0x30, 0x24, 0x4d, 0x37, 0xe9, 0xa1,
	0xf3, 0xd9, 0x79, 0xd8, 0x50, 0x58, 0xef, 0xdc, 0x7c, 0x76, 0x43, 0x99, 0x15, 0x9e, 0x0f, 0xe6,
	0x31, 0x0e, 0xea, 0x62, 0x33, 0xc4, 0x0a, 0xf8, 0x35, 0xd8, 0x64, 0xb1, 0xf0, 0xe0, 0xe6, 0xb2,
	0x03, 0xd3, 0xee, 0xcf, 0x38, 0xe6, 0x0a, 0x8d, 0x7e, 0xef, 0xd7, 0x6a, 0xed, 0xce, 0x7e, 0x54,
	0x94, 0xd8, 0x6a, 0x99, 0xda, 0x9e, 0xd8, 0xd1, 0xcc, 0x9d, 0x7d, 0x53, 0x15, 0x75, 0xb9, 0xcd,
	0xa7, 0xf0, 0x1b, 0x70, 0x93, 0xa1, 0x28, 0xd2, 0x9e, 0x59, 0x97, 0x94, 0xf6, 0xee, 0x3c, 0x11,
	0xe1, 0x9b, 0x50, 0x66, 0x88, 0x75, 0xa9, 0x25, 0x35, 0x03, 0x44, 0x61, 0x48, 0xdc, 0x1c, 0x89,
	0x26, 0xd4, 0xc5, 0xfb, 0xb2, 0xd2, 0x9c, 0x91, 0xd2, 0x78, 0x1b, 0x5e, 0x67, 0x48, 0x0d, 0x59,
	0xd4, 0xcd, 0x76, 0xa3, 0xa1, 0x8a, 0xbb, 0x1d, 0x53, 0x13, 0x5b, 0x12, 0x13, 0x30, 0x83, 0x6f,
	0xc1, 0x9b, 0x09, 0xae, 0x42, 0xa9, 0x1d, 0x43, 0xad, 0xdd, 0x13, 0x35, 0x96, 0xbe, 0xc4, 0x34,
	0xe3, 0x2b, 0x04, 0x85, 0xe9, 0x87, 0xec, 0xec, 0x67, 0x1f, 0x75, 0x59, 0xeb, 0x48, 0x35, 0xb9,
	0x21, 0x4b, 0x75, 0x3e, 0x85, 0x2f, 0xc2, 0x0a, 0x83, 0x69, 0x52, 0xab, 0xc5, 0x23, 0x8c, 0x61,
	0x99, 0x31, 0xee, 0x18, 0xfb, 0x3c, 0x37, 0x47, 0x6c, 0xb5, 0x45, 0x85, 0x4f, 0xcf, 0x19, 0x9b,
	0xf2, 0xc3, 0x60, 0xa6, 0xa6, 0x97, 0x0f, 0x33, 0xcd, 0xac, 0xba, 0x9d, 0xed, 0xe7, 0x2f, 0x4b,
	0xe8, 0xc5, 0xcb, 0x12, 0xfa, 0xf5, 0x65, 0x09, 0x3d, 0x7d, 0x55, 0x4a, 0xbd, 0x78, 0x55, 0x4a,
	0xfd, 0xf4, 0xaa, 0x94, 0x7a, 0x8f, 0xfe, 0xd9, 0xac, 0x7e, 0x44, 0xff, 0x46, 0x06, 0x77, 0xbc,
	0x7f, 0x90, 0xa5, 0x17, 0xeb, 0xdb, 0x7f, 0x07, 0x00, 0x00, 0xff, 0xff, 0x0d, 0x38, 0xc2, 0x1e,
	0xa7, 0x0e, 0x00, 0x00,
}

func (this *ActionTag) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*ActionTag)
	if !ok {
		that2, ok := that.(ActionTag)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Tag != that1.Tag {
		return false
	}
	if this.ActionId != that1.ActionId {
		return false
	}
	if this.ActionType != that1.ActionType {
		return false
	}
	if this.CreatorAddr != that1.CreatorAddr {
		return false
	}
	if this.Magnitude != that1.Magnitude {
		return false
	}
	if !this.TaggedAt.Equal(that1.TaggedAt) {
		return false
	}
	return true
}
func (m *ActionInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ActionInfo) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ActionInfo) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	n1, err1 := github_com_gogo_protobuf_types.StdTimeMarshalTo(m.CreatedAt, dAtA[i-github_com_gogo_protobuf_types.SizeOfStdTime(m.CreatedAt):])
	if err1 != nil {
		return 0, err1
	}
	i -= n1
	i = encodeVarintActions(dAtA, i, uint64(n1))
	i--
	dAtA[i] = 0x4a
	if len(m.Tags) > 0 {
		for iNdEx := len(m.Tags) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Tags[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintActions(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x42
		}
	}
	if len(m.CreatorAddr) > 0 {
		i -= len(m.CreatorAddr)
		copy(dAtA[i:], m.CreatorAddr)
		i = encodeVarintActions(dAtA, i, uint64(len(m.CreatorAddr)))
		i--
		dAtA[i] = 0x3a
	}
	if m.Info != nil {
		{
			size, err := m.Info.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintActions(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x32
	}
	if m.Status != 0 {
		i = encodeVarintActions(dAtA, i, uint64(m.Status))
		i--
		dAtA[i] = 0x28
	}
	if m.Type != 0 {
		i = encodeVarintActions(dAtA, i, uint64(m.Type))
		i--
		dAtA[i] = 0x20
	}
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintActions(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0x1a
	}
	if m.ActionId != 0 {
		i = encodeVarintActions(dAtA, i, uint64(m.ActionId))
		i--
		dAtA[i] = 0x10
	}
	if m.Id != 0 {
		i = encodeVarintActions(dAtA, i, uint64(m.Id))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *CancelNameAction) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CancelNameAction) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CancelNameAction) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Data != nil {
		{
			size, err := m.Data.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintActions(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2a
	}
	if len(m.Reason) > 0 {
		i -= len(m.Reason)
		copy(dAtA[i:], m.Reason)
		i = encodeVarintActions(dAtA, i, uint64(len(m.Reason)))
		i--
		dAtA[i] = 0x22
	}
	if m.CancelActionId != 0 {
		i = encodeVarintActions(dAtA, i, uint64(m.CancelActionId))
		i--
		dAtA[i] = 0x18
	}
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintActions(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0x12
	}
	if m.Id != 0 {
		i = encodeVarintActions(dAtA, i, uint64(m.Id))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *RequestOrderName) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RequestOrderName) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *RequestOrderName) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Data != nil {
		{
			size, err := m.Data.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintActions(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	if len(m.Reason) > 0 {
		i -= len(m.Reason)
		copy(dAtA[i:], m.Reason)
		i = encodeVarintActions(dAtA, i, uint64(len(m.Reason)))
		i--
		dAtA[i] = 0x1a
	}
	if m.OrderType != 0 {
		i = encodeVarintActions(dAtA, i, uint64(m.OrderType))
		i--
		dAtA[i] = 0x10
	}
	if m.Id != 0 {
		i = encodeVarintActions(dAtA, i, uint64(m.Id))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *MuteName) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MuteName) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MuteName) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Data != nil {
		{
			size, err := m.Data.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintActions(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	if m.Block {
		i--
		if m.Block {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x18
	}
	if len(m.Reason) > 0 {
		i -= len(m.Reason)
		copy(dAtA[i:], m.Reason)
		i = encodeVarintActions(dAtA, i, uint64(len(m.Reason)))
		i--
		dAtA[i] = 0x12
	}
	if m.Id != 0 {
		i = encodeVarintActions(dAtA, i, uint64(m.Id))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *ReportName) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ReportName) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ReportName) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Data != nil {
		{
			size, err := m.Data.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintActions(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	if m.Mute {
		i--
		if m.Mute {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x18
	}
	if len(m.Reason) > 0 {
		i -= len(m.Reason)
		copy(dAtA[i:], m.Reason)
		i = encodeVarintActions(dAtA, i, uint64(len(m.Reason)))
		i--
		dAtA[i] = 0x12
	}
	if m.Id != 0 {
		i = encodeVarintActions(dAtA, i, uint64(m.Id))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *InviteName) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *InviteName) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *InviteName) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Data != nil {
		{
			size, err := m.Data.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintActions(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2a
	}
	if m.GroupId != 0 {
		i = encodeVarintActions(dAtA, i, uint64(m.GroupId))
		i--
		dAtA[i] = 0x20
	}
	if len(m.Content) > 0 {
		i -= len(m.Content)
		copy(dAtA[i:], m.Content)
		i = encodeVarintActions(dAtA, i, uint64(len(m.Content)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Title) > 0 {
		i -= len(m.Title)
		copy(dAtA[i:], m.Title)
		i = encodeVarintActions(dAtA, i, uint64(len(m.Title)))
		i--
		dAtA[i] = 0x12
	}
	if m.Id != 0 {
		i = encodeVarintActions(dAtA, i, uint64(m.Id))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *MessageName) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MessageName) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MessageName) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Data != nil {
		{
			size, err := m.Data.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintActions(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	if len(m.Content) > 0 {
		i -= len(m.Content)
		copy(dAtA[i:], m.Content)
		i = encodeVarintActions(dAtA, i, uint64(len(m.Content)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Title) > 0 {
		i -= len(m.Title)
		copy(dAtA[i:], m.Title)
		i = encodeVarintActions(dAtA, i, uint64(len(m.Title)))
		i--
		dAtA[i] = 0x12
	}
	if m.Id != 0 {
		i = encodeVarintActions(dAtA, i, uint64(m.Id))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *TagName) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TagName) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TagName) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Data != nil {
		{
			size, err := m.Data.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintActions(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2a
	}
	if m.Follow {
		i--
		if m.Follow {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x20
	}
	if len(m.Message) > 0 {
		i -= len(m.Message)
		copy(dAtA[i:], m.Message)
		i = encodeVarintActions(dAtA, i, uint64(len(m.Message)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Tags) > 0 {
		for iNdEx := len(m.Tags) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Tags[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintActions(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
		}
	}
	if m.Id != 0 {
		i = encodeVarintActions(dAtA, i, uint64(m.Id))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *FollowName) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *FollowName) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *FollowName) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Data != nil {
		{
			size, err := m.Data.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintActions(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	if m.TradeFollow {
		i--
		if m.TradeFollow {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x18
	}
	if len(m.Message) > 0 {
		i -= len(m.Message)
		copy(dAtA[i:], m.Message)
		i = encodeVarintActions(dAtA, i, uint64(len(m.Message)))
		i--
		dAtA[i] = 0x12
	}
	if m.Id != 0 {
		i = encodeVarintActions(dAtA, i, uint64(m.Id))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *TradeFollowName) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TradeFollowName) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TradeFollowName) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Data != nil {
		{
			size, err := m.Data.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintActions(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	if len(m.Message) > 0 {
		i -= len(m.Message)
		copy(dAtA[i:], m.Message)
		i = encodeVarintActions(dAtA, i, uint64(len(m.Message)))
		i--
		dAtA[i] = 0x1a
	}
	if m.CopyTrades {
		i--
		if m.CopyTrades {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x10
	}
	if m.Id != 0 {
		i = encodeVarintActions(dAtA, i, uint64(m.Id))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *CopyTradeName) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CopyTradeName) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CopyTradeName) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Data != nil {
		{
			size, err := m.Data.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintActions(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2a
	}
	if m.CopyTradeType != 0 {
		i = encodeVarintActions(dAtA, i, uint64(m.CopyTradeType))
		i--
		dAtA[i] = 0x20
	}
	if len(m.Message) > 0 {
		i -= len(m.Message)
		copy(dAtA[i:], m.Message)
		i = encodeVarintActions(dAtA, i, uint64(len(m.Message)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.CopyTradeParams) > 0 {
		i -= len(m.CopyTradeParams)
		copy(dAtA[i:], m.CopyTradeParams)
		i = encodeVarintActions(dAtA, i, uint64(len(m.CopyTradeParams)))
		i--
		dAtA[i] = 0x12
	}
	if m.Id != 0 {
		i = encodeVarintActions(dAtA, i, uint64(m.Id))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *ActionTag) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ActionTag) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ActionTag) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	n13, err13 := github_com_gogo_protobuf_types.StdTimeMarshalTo(m.TaggedAt, dAtA[i-github_com_gogo_protobuf_types.SizeOfStdTime(m.TaggedAt):])
	if err13 != nil {
		return 0, err13
	}
	i -= n13
	i = encodeVarintActions(dAtA, i, uint64(n13))
	i--
	dAtA[i] = 0x32
	if m.Magnitude != 0 {
		i = encodeVarintActions(dAtA, i, uint64(m.Magnitude))
		i--
		dAtA[i] = 0x28
	}
	if len(m.CreatorAddr) > 0 {
		i -= len(m.CreatorAddr)
		copy(dAtA[i:], m.CreatorAddr)
		i = encodeVarintActions(dAtA, i, uint64(len(m.CreatorAddr)))
		i--
		dAtA[i] = 0x22
	}
	if m.ActionType != 0 {
		i = encodeVarintActions(dAtA, i, uint64(m.ActionType))
		i--
		dAtA[i] = 0x18
	}
	if m.ActionId != 0 {
		i = encodeVarintActions(dAtA, i, uint64(m.ActionId))
		i--
		dAtA[i] = 0x10
	}
	if len(m.Tag) > 0 {
		i -= len(m.Tag)
		copy(dAtA[i:], m.Tag)
		i = encodeVarintActions(dAtA, i, uint64(len(m.Tag)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func encodeVarintActions(dAtA []byte, offset int, v uint64) int {
	offset -= sovActions(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *ActionInfo) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Id != 0 {
		n += 1 + sovActions(uint64(m.Id))
	}
	if m.ActionId != 0 {
		n += 1 + sovActions(uint64(m.ActionId))
	}
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovActions(uint64(l))
	}
	if m.Type != 0 {
		n += 1 + sovActions(uint64(m.Type))
	}
	if m.Status != 0 {
		n += 1 + sovActions(uint64(m.Status))
	}
	if m.Info != nil {
		l = m.Info.Size()
		n += 1 + l + sovActions(uint64(l))
	}
	l = len(m.CreatorAddr)
	if l > 0 {
		n += 1 + l + sovActions(uint64(l))
	}
	if len(m.Tags) > 0 {
		for _, e := range m.Tags {
			l = e.Size()
			n += 1 + l + sovActions(uint64(l))
		}
	}
	l = github_com_gogo_protobuf_types.SizeOfStdTime(m.CreatedAt)
	n += 1 + l + sovActions(uint64(l))
	return n
}

func (m *CancelNameAction) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Id != 0 {
		n += 1 + sovActions(uint64(m.Id))
	}
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovActions(uint64(l))
	}
	if m.CancelActionId != 0 {
		n += 1 + sovActions(uint64(m.CancelActionId))
	}
	l = len(m.Reason)
	if l > 0 {
		n += 1 + l + sovActions(uint64(l))
	}
	if m.Data != nil {
		l = m.Data.Size()
		n += 1 + l + sovActions(uint64(l))
	}
	return n
}

func (m *RequestOrderName) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Id != 0 {
		n += 1 + sovActions(uint64(m.Id))
	}
	if m.OrderType != 0 {
		n += 1 + sovActions(uint64(m.OrderType))
	}
	l = len(m.Reason)
	if l > 0 {
		n += 1 + l + sovActions(uint64(l))
	}
	if m.Data != nil {
		l = m.Data.Size()
		n += 1 + l + sovActions(uint64(l))
	}
	return n
}

func (m *MuteName) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Id != 0 {
		n += 1 + sovActions(uint64(m.Id))
	}
	l = len(m.Reason)
	if l > 0 {
		n += 1 + l + sovActions(uint64(l))
	}
	if m.Block {
		n += 2
	}
	if m.Data != nil {
		l = m.Data.Size()
		n += 1 + l + sovActions(uint64(l))
	}
	return n
}

func (m *ReportName) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Id != 0 {
		n += 1 + sovActions(uint64(m.Id))
	}
	l = len(m.Reason)
	if l > 0 {
		n += 1 + l + sovActions(uint64(l))
	}
	if m.Mute {
		n += 2
	}
	if m.Data != nil {
		l = m.Data.Size()
		n += 1 + l + sovActions(uint64(l))
	}
	return n
}

func (m *InviteName) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Id != 0 {
		n += 1 + sovActions(uint64(m.Id))
	}
	l = len(m.Title)
	if l > 0 {
		n += 1 + l + sovActions(uint64(l))
	}
	l = len(m.Content)
	if l > 0 {
		n += 1 + l + sovActions(uint64(l))
	}
	if m.GroupId != 0 {
		n += 1 + sovActions(uint64(m.GroupId))
	}
	if m.Data != nil {
		l = m.Data.Size()
		n += 1 + l + sovActions(uint64(l))
	}
	return n
}

func (m *MessageName) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Id != 0 {
		n += 1 + sovActions(uint64(m.Id))
	}
	l = len(m.Title)
	if l > 0 {
		n += 1 + l + sovActions(uint64(l))
	}
	l = len(m.Content)
	if l > 0 {
		n += 1 + l + sovActions(uint64(l))
	}
	if m.Data != nil {
		l = m.Data.Size()
		n += 1 + l + sovActions(uint64(l))
	}
	return n
}

func (m *TagName) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Id != 0 {
		n += 1 + sovActions(uint64(m.Id))
	}
	if len(m.Tags) > 0 {
		for _, e := range m.Tags {
			l = e.Size()
			n += 1 + l + sovActions(uint64(l))
		}
	}
	l = len(m.Message)
	if l > 0 {
		n += 1 + l + sovActions(uint64(l))
	}
	if m.Follow {
		n += 2
	}
	if m.Data != nil {
		l = m.Data.Size()
		n += 1 + l + sovActions(uint64(l))
	}
	return n
}

func (m *FollowName) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Id != 0 {
		n += 1 + sovActions(uint64(m.Id))
	}
	l = len(m.Message)
	if l > 0 {
		n += 1 + l + sovActions(uint64(l))
	}
	if m.TradeFollow {
		n += 2
	}
	if m.Data != nil {
		l = m.Data.Size()
		n += 1 + l + sovActions(uint64(l))
	}
	return n
}

func (m *TradeFollowName) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Id != 0 {
		n += 1 + sovActions(uint64(m.Id))
	}
	if m.CopyTrades {
		n += 2
	}
	l = len(m.Message)
	if l > 0 {
		n += 1 + l + sovActions(uint64(l))
	}
	if m.Data != nil {
		l = m.Data.Size()
		n += 1 + l + sovActions(uint64(l))
	}
	return n
}

func (m *CopyTradeName) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Id != 0 {
		n += 1 + sovActions(uint64(m.Id))
	}
	l = len(m.CopyTradeParams)
	if l > 0 {
		n += 1 + l + sovActions(uint64(l))
	}
	l = len(m.Message)
	if l > 0 {
		n += 1 + l + sovActions(uint64(l))
	}
	if m.CopyTradeType != 0 {
		n += 1 + sovActions(uint64(m.CopyTradeType))
	}
	if m.Data != nil {
		l = m.Data.Size()
		n += 1 + l + sovActions(uint64(l))
	}
	return n
}

func (m *ActionTag) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Tag)
	if l > 0 {
		n += 1 + l + sovActions(uint64(l))
	}
	if m.ActionId != 0 {
		n += 1 + sovActions(uint64(m.ActionId))
	}
	if m.ActionType != 0 {
		n += 1 + sovActions(uint64(m.ActionType))
	}
	l = len(m.CreatorAddr)
	if l > 0 {
		n += 1 + l + sovActions(uint64(l))
	}
	if m.Magnitude != 0 {
		n += 1 + sovActions(uint64(m.Magnitude))
	}
	l = github_com_gogo_protobuf_types.SizeOfStdTime(m.TaggedAt)
	n += 1 + l + sovActions(uint64(l))
	return n
}

func sovActions(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozActions(x uint64) (n int) {
	return sovActions(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *ActionInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowActions
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ActionInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ActionInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			m.Id = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowActions
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Id |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ActionId", wireType)
			}
			m.ActionId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowActions
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ActionId |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowActions
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthActions
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthActions
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			m.Type = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowActions
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Type |= ActionType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			m.Status = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowActions
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Status |= ActionStatus(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Info", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowActions
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthActions
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthActions
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Info == nil {
				m.Info = &ActionInfo{}
			}
			if err := m.Info.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CreatorAddr", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowActions
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthActions
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthActions
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CreatorAddr = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Tags", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowActions
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthActions
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthActions
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Tags = append(m.Tags, &ActionTag{})
			if err := m.Tags[len(m.Tags)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CreatedAt", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowActions
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthActions
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthActions
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := github_com_gogo_protobuf_types.StdTimeUnmarshal(&m.CreatedAt, dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipActions(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthActions
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CancelNameAction) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowActions
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CancelNameAction: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CancelNameAction: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			m.Id = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowActions
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Id |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowActions
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthActions
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthActions
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CancelActionId", wireType)
			}
			m.CancelActionId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowActions
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CancelActionId |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Reason", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowActions
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthActions
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthActions
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Reason = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Data", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowActions
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthActions
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthActions
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Data == nil {
				m.Data = &ActionInfo{}
			}
			if err := m.Data.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipActions(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthActions
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RequestOrderName) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowActions
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RequestOrderName: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RequestOrderName: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			m.Id = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowActions
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Id |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field OrderType", wireType)
			}
			m.OrderType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowActions
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.OrderType |= OrderType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Reason", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowActions
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthActions
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthActions
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Reason = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Data", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowActions
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthActions
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthActions
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Data == nil {
				m.Data = &ActionInfo{}
			}
			if err := m.Data.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipActions(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthActions
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MuteName) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowActions
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MuteName: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MuteName: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			m.Id = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowActions
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Id |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Reason", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowActions
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthActions
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthActions
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Reason = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Block", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowActions
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Block = bool(v != 0)
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Data", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowActions
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthActions
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthActions
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Data == nil {
				m.Data = &ActionInfo{}
			}
			if err := m.Data.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipActions(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthActions
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ReportName) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowActions
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ReportName: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ReportName: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			m.Id = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowActions
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Id |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Reason", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowActions
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthActions
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthActions
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Reason = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Mute", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowActions
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Mute = bool(v != 0)
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Data", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowActions
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthActions
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthActions
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Data == nil {
				m.Data = &ActionInfo{}
			}
			if err := m.Data.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipActions(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthActions
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *InviteName) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowActions
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: InviteName: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: InviteName: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			m.Id = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowActions
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Id |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Title", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowActions
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthActions
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthActions
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Title = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Content", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowActions
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthActions
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthActions
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Content = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field GroupId", wireType)
			}
			m.GroupId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowActions
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.GroupId |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Data", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowActions
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthActions
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthActions
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Data == nil {
				m.Data = &ActionInfo{}
			}
			if err := m.Data.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipActions(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthActions
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MessageName) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowActions
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MessageName: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MessageName: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			m.Id = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowActions
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Id |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Title", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowActions
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthActions
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthActions
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Title = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Content", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowActions
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthActions
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthActions
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Content = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Data", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowActions
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthActions
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthActions
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Data == nil {
				m.Data = &ActionInfo{}
			}
			if err := m.Data.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipActions(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthActions
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TagName) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowActions
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TagName: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TagName: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			m.Id = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowActions
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Id |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Tags", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowActions
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthActions
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthActions
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Tags = append(m.Tags, &NameTag{})
			if err := m.Tags[len(m.Tags)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Message", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowActions
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthActions
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthActions
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Message = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Follow", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowActions
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Follow = bool(v != 0)
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Data", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowActions
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthActions
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthActions
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Data == nil {
				m.Data = &ActionInfo{}
			}
			if err := m.Data.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipActions(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthActions
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *FollowName) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowActions
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: FollowName: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: FollowName: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			m.Id = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowActions
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Id |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Message", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowActions
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthActions
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthActions
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Message = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TradeFollow", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowActions
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.TradeFollow = bool(v != 0)
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Data", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowActions
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthActions
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthActions
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Data == nil {
				m.Data = &ActionInfo{}
			}
			if err := m.Data.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipActions(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthActions
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TradeFollowName) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowActions
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TradeFollowName: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TradeFollowName: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			m.Id = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowActions
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Id |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CopyTrades", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowActions
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.CopyTrades = bool(v != 0)
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Message", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowActions
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthActions
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthActions
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Message = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Data", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowActions
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthActions
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthActions
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Data == nil {
				m.Data = &ActionInfo{}
			}
			if err := m.Data.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipActions(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthActions
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CopyTradeName) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowActions
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CopyTradeName: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CopyTradeName: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			m.Id = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowActions
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Id |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CopyTradeParams", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowActions
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthActions
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthActions
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CopyTradeParams = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Message", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowActions
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthActions
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthActions
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Message = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CopyTradeType", wireType)
			}
			m.CopyTradeType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowActions
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CopyTradeType |= CopyTradeType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Data", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowActions
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthActions
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthActions
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Data == nil {
				m.Data = &ActionInfo{}
			}
			if err := m.Data.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipActions(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthActions
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ActionTag) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowActions
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ActionTag: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ActionTag: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Tag", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowActions
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthActions
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthActions
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Tag = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ActionId", wireType)
			}
			m.ActionId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowActions
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ActionId |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ActionType", wireType)
			}
			m.ActionType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowActions
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ActionType |= ActionType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CreatorAddr", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowActions
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthActions
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthActions
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CreatorAddr = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Magnitude", wireType)
			}
			m.Magnitude = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowActions
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Magnitude |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TaggedAt", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowActions
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthActions
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthActions
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := github_com_gogo_protobuf_types.StdTimeUnmarshal(&m.TaggedAt, dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipActions(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthActions
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipActions(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowActions
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowActions
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowActions
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthActions
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupActions
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthActions
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthActions        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowActions          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupActions = fmt.Errorf("proto: unexpected end of group")
)
