// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: ollo/prices/v1/prices.proto

package types

import (
	bytes "bytes"
	fmt "fmt"
	github_com_cosmos_cosmos_sdk_types "github.com/cosmos/cosmos-sdk/types"
	_ "github.com/gogo/protobuf/gogoproto"
	proto "github.com/gogo/protobuf/proto"
	io "io"
	math "math"
	math_bits "math/bits"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion3 // please upgrade the proto package

// DataProvider is the type defined for feed data provider
type DataProvider struct {
	Address github_com_cosmos_cosmos_sdk_types.AccAddress `protobuf:"bytes,1,opt,name=address,proto3,casttype=github.com/cosmos/cosmos-sdk/types.AccAddress" json:"address,omitempty"`
	PubKey  []byte                                        `protobuf:"bytes,2,opt,name=pubKey,proto3" json:"pubKey,omitempty"`
}

func (m *DataProvider) Reset()         { *m = DataProvider{} }
func (m *DataProvider) String() string { return proto.CompactTextString(m) }
func (*DataProvider) ProtoMessage()    {}
func (*DataProvider) Descriptor() ([]byte, []int) {
	return fileDescriptor_407eea22785d1762, []int{0}
}
func (m *DataProvider) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DataProvider) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_DataProvider.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *DataProvider) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DataProvider.Merge(m, src)
}
func (m *DataProvider) XXX_Size() int {
	return m.Size()
}
func (m *DataProvider) XXX_DiscardUnknown() {
	xxx_messageInfo_DataProvider.DiscardUnknown(m)
}

var xxx_messageInfo_DataProvider proto.InternalMessageInfo

type MsgModuleOwner struct {
	// address defines the address of the module owner
	Address github_com_cosmos_cosmos_sdk_types.AccAddress `protobuf:"bytes,1,opt,name=address,proto3,casttype=github.com/cosmos/cosmos-sdk/types.AccAddress" json:"address,omitempty" yaml:"address"`
	// pubKey defined the public key of the module owner
	PubKey []byte `protobuf:"bytes,2,opt,name=pubKey,proto3" json:"pubKey,omitempty" yaml:"pub_key"`
	// the module owner who assigned this new module owner
	AssignerAddress github_com_cosmos_cosmos_sdk_types.AccAddress `protobuf:"bytes,3,opt,name=assignerAddress,proto3,casttype=github.com/cosmos/cosmos-sdk/types.AccAddress" json:"assignerAddress,omitempty"`
}

func (m *MsgModuleOwner) Reset()         { *m = MsgModuleOwner{} }
func (m *MsgModuleOwner) String() string { return proto.CompactTextString(m) }
func (*MsgModuleOwner) ProtoMessage()    {}
func (*MsgModuleOwner) Descriptor() ([]byte, []int) {
	return fileDescriptor_407eea22785d1762, []int{1}
}
func (m *MsgModuleOwner) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgModuleOwner) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgModuleOwner.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgModuleOwner) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgModuleOwner.Merge(m, src)
}
func (m *MsgModuleOwner) XXX_Size() int {
	return m.Size()
}
func (m *MsgModuleOwner) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgModuleOwner.DiscardUnknown(m)
}

var xxx_messageInfo_MsgModuleOwner proto.InternalMessageInfo

// this will be the implementation used later will use pseudo OCR ABI encoded
// data instead because the structure of how the OCR will be generalized is
// still unknown OCRAbiEncoded implments the OCR data that is ABCI encoded. The
// use and form will conform to the Chainlink protocol specification.
type OCRAbiEncoded struct {
	// Context should be a 32-byte array struct.
	Context []byte `protobuf:"bytes,1,opt,name=Context,proto3" json:"Context,omitempty"`
	// Oracles should be a 32-byte record of all participating oracles. Assuming
	// this is data provider address?
	Oracles []byte `protobuf:"bytes,2,opt,name=Oracles,proto3" json:"Oracles,omitempty"`
	// Observations should be an array on int192 containing the providers'
	// independent observations.
	Observations []*Observation `protobuf:"bytes,3,rep,name=Observations,proto3" json:"Observations,omitempty"`
}

func (m *OCRAbiEncoded) Reset()         { *m = OCRAbiEncoded{} }
func (m *OCRAbiEncoded) String() string { return proto.CompactTextString(m) }
func (*OCRAbiEncoded) ProtoMessage()    {}
func (*OCRAbiEncoded) Descriptor() ([]byte, []int) {
	return fileDescriptor_407eea22785d1762, []int{2}
}
func (m *OCRAbiEncoded) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *OCRAbiEncoded) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_OCRAbiEncoded.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *OCRAbiEncoded) XXX_Merge(src proto.Message) {
	xxx_messageInfo_OCRAbiEncoded.Merge(m, src)
}
func (m *OCRAbiEncoded) XXX_Size() int {
	return m.Size()
}
func (m *OCRAbiEncoded) XXX_DiscardUnknown() {
	xxx_messageInfo_OCRAbiEncoded.DiscardUnknown(m)
}

var xxx_messageInfo_OCRAbiEncoded proto.InternalMessageInfo

type Observation struct {
	Data []byte `protobuf:"bytes,1,opt,name=data,proto3" json:"data,omitempty"`
}

func (m *Observation) Reset()         { *m = Observation{} }
func (m *Observation) String() string { return proto.CompactTextString(m) }
func (*Observation) ProtoMessage()    {}
func (*Observation) Descriptor() ([]byte, []int) {
	return fileDescriptor_407eea22785d1762, []int{3}
}
func (m *Observation) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Observation) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Observation.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Observation) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Observation.Merge(m, src)
}
func (m *Observation) XXX_Size() int {
	return m.Size()
}
func (m *Observation) XXX_DiscardUnknown() {
	xxx_messageInfo_Observation.DiscardUnknown(m)
}

var xxx_messageInfo_Observation proto.InternalMessageInfo

type FeedRewardSchema struct {
	// amount is the base value that rewarded to each valid data provider before
	// designated strategy applied amount is not allowed to be zero
	Amount uint64 `protobuf:"varint,1,opt,name=amount,proto3" json:"amount,omitempty"`
	// reward strategy name, must be a registered strategy
	// this is allowed to be empty, in which case every data provider will be
	// rewarded the same amount token
	Strategy string `protobuf:"bytes,2,opt,name=strategy,proto3" json:"strategy,omitempty"`
}

func (m *FeedRewardSchema) Reset()         { *m = FeedRewardSchema{} }
func (m *FeedRewardSchema) String() string { return proto.CompactTextString(m) }
func (*FeedRewardSchema) ProtoMessage()    {}
func (*FeedRewardSchema) Descriptor() ([]byte, []int) {
	return fileDescriptor_407eea22785d1762, []int{4}
}
func (m *FeedRewardSchema) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *FeedRewardSchema) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_FeedRewardSchema.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *FeedRewardSchema) XXX_Merge(src proto.Message) {
	xxx_messageInfo_FeedRewardSchema.Merge(m, src)
}
func (m *FeedRewardSchema) XXX_Size() int {
	return m.Size()
}
func (m *FeedRewardSchema) XXX_DiscardUnknown() {
	xxx_messageInfo_FeedRewardSchema.DiscardUnknown(m)
}

var xxx_messageInfo_FeedRewardSchema proto.InternalMessageInfo

func init() {
	proto.RegisterType((*DataProvider)(nil), "ollo.prices.v1.DataProvider")
	proto.RegisterType((*MsgModuleOwner)(nil), "ollo.prices.v1.MsgModuleOwner")
	proto.RegisterType((*OCRAbiEncoded)(nil), "ollo.prices.v1.OCRAbiEncoded")
	proto.RegisterType((*Observation)(nil), "ollo.prices.v1.Observation")
	proto.RegisterType((*FeedRewardSchema)(nil), "ollo.prices.v1.FeedRewardSchema")
}

func init() { proto.RegisterFile("ollo/prices/v1/prices.proto", fileDescriptor_407eea22785d1762) }

var fileDescriptor_407eea22785d1762 = []byte{
	// 453 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xa4, 0x92, 0xc1, 0x6e, 0xd3, 0x30,
	0x18, 0xc7, 0x63, 0x36, 0x6d, 0xe0, 0x95, 0x82, 0x2c, 0x84, 0xaa, 0x4d, 0x72, 0x21, 0xa7, 0x09,
	0xd4, 0x44, 0x05, 0x71, 0xe1, 0x82, 0xda, 0xc2, 0x2e, 0xd3, 0x54, 0x14, 0xc4, 0x05, 0x09, 0x4d,
	0x8e, 0xfd, 0x29, 0x8b, 0x96, 0xc4, 0x91, 0xed, 0x74, 0xeb, 0x9d, 0x07, 0xe0, 0x31, 0x78, 0x94,
	0x1e, 0x7b, 0xe4, 0x54, 0xad, 0xed, 0x1b, 0x70, 0x44, 0x1c, 0x50, 0x12, 0x07, 0xda, 0xdd, 0x10,
	0xa7, 0x7c, 0xff, 0x7c, 0xfe, 0xfe, 0xfe, 0xf9, 0x6f, 0xe3, 0x23, 0x99, 0x24, 0xd2, 0xcf, 0x55,
	0xcc, 0x41, 0xfb, 0x93, 0xbe, 0xad, 0xbc, 0x5c, 0x49, 0x23, 0x49, 0xbb, 0x6c, 0x7a, 0xf6, 0xd7,
	0xa4, 0x7f, 0xf8, 0x28, 0x92, 0x91, 0xac, 0x5a, 0x7e, 0x59, 0xd5, 0xab, 0x5c, 0x8d, 0x5b, 0x6f,
	0x99, 0x61, 0xef, 0x95, 0x9c, 0xc4, 0x02, 0x14, 0x39, 0xc5, 0xfb, 0x4c, 0x08, 0x05, 0x5a, 0x77,
	0xd0, 0x13, 0x74, 0xdc, 0x1a, 0xf6, 0x7f, 0x2e, 0xba, 0xbd, 0x28, 0x36, 0x17, 0x45, 0xe8, 0x71,
	0x99, 0xfa, 0x5c, 0xea, 0x54, 0x6a, 0xfb, 0xe9, 0x69, 0x71, 0xe9, 0x9b, 0x69, 0x0e, 0xda, 0x1b,
	0x70, 0x3e, 0xa8, 0x07, 0x83, 0xc6, 0x81, 0x3c, 0xc6, 0x7b, 0x79, 0x11, 0x9e, 0xc2, 0xb4, 0x73,
	0xa7, 0xf4, 0x0a, 0xac, 0x72, 0x7f, 0x21, 0xdc, 0x3e, 0xd3, 0xd1, 0x99, 0x14, 0x45, 0x02, 0xe3,
	0xab, 0x0c, 0x14, 0xf9, 0x7c, 0x7b, 0xdf, 0xd1, 0x8f, 0x45, 0xb7, 0x3d, 0x65, 0x69, 0xf2, 0xda,
	0xb5, 0x0d, 0xf7, 0x3f, 0x48, 0x9e, 0x6d, 0x93, 0x0c, 0xc9, 0x5f, 0xf7, 0xbc, 0x08, 0xcf, 0x2f,
	0x61, 0xea, 0x36, 0x74, 0xe4, 0x1c, 0x3f, 0x60, 0x5a, 0xc7, 0x51, 0x06, 0xca, 0xfa, 0x74, 0x76,
	0xaa, 0xa1, 0x57, 0xb3, 0x45, 0x17, 0xfd, 0x3b, 0xc4, 0x6d, 0x37, 0xf7, 0x0b, 0xc2, 0xf7, 0xc7,
	0xa3, 0x60, 0x10, 0xc6, 0xef, 0x32, 0x2e, 0x05, 0x08, 0xd2, 0xc1, 0xfb, 0x23, 0x99, 0x19, 0xb8,
	0x36, 0xf5, 0xe9, 0x83, 0x46, 0x96, 0x9d, 0xb1, 0x62, 0x3c, 0x01, 0x6d, 0x33, 0x6c, 0x24, 0x79,
	0x83, 0x5b, 0xe3, 0x50, 0x83, 0x9a, 0x30, 0x13, 0xcb, 0xac, 0x64, 0xdc, 0x39, 0x3e, 0x78, 0x71,
	0xe4, 0x6d, 0x5f, 0xbb, 0xb7, 0xb1, 0x26, 0xd8, 0x1a, 0x70, 0x9f, 0xe2, 0x83, 0x0d, 0x4d, 0x08,
	0xde, 0x15, 0xcc, 0x30, 0x0b, 0x50, 0xd5, 0xee, 0x09, 0x7e, 0x78, 0x02, 0x20, 0x02, 0xb8, 0x62,
	0x4a, 0x7c, 0xe0, 0x17, 0x90, 0xb2, 0xf2, 0x52, 0x59, 0x2a, 0x8b, 0xac, 0x46, 0xdd, 0x0d, 0xac,
	0x22, 0x87, 0xf8, 0xae, 0x36, 0x8a, 0x19, 0x88, 0xea, 0x90, 0xef, 0x05, 0x7f, 0xf4, 0xf0, 0xe3,
	0x6c, 0x49, 0x9d, 0xf9, 0x92, 0x3a, 0x37, 0x4b, 0x8a, 0xbe, 0xad, 0x28, 0x9a, 0xad, 0x28, 0x9a,
	0xaf, 0x28, 0xba, 0x59, 0x51, 0xf4, 0x75, 0x4d, 0x9d, 0xf9, 0x9a, 0x3a, 0xdf, 0xd7, 0xd4, 0xf9,
	0xf4, 0x7c, 0x23, 0xdb, 0xf2, 0x24, 0x3d, 0x6d, 0x2a, 0xbc, 0x4a, 0xf8, 0xd7, 0xcd, 0x63, 0xaf,
	0x42, 0x0e, 0xf7, 0xaa, 0x37, 0xfc, 0xf2, 0x77, 0x00, 0x00, 0x00, 0xff, 0xff, 0x9f, 0xca, 0x40,
	0xf6, 0x08, 0x03, 0x00, 0x00,
}

func (this *DataProvider) VerboseEqual(that interface{}) error {
	if that == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that == nil && this != nil")
	}

	that1, ok := that.(*DataProvider)
	if !ok {
		that2, ok := that.(DataProvider)
		if ok {
			that1 = &that2
		} else {
			return fmt.Errorf("that is not of type *DataProvider")
		}
	}
	if that1 == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that is type *DataProvider but is nil && this != nil")
	} else if this == nil {
		return fmt.Errorf("that is type *DataProvider but is not nil && this == nil")
	}
	if !bytes.Equal(this.Address, that1.Address) {
		return fmt.Errorf("Address this(%v) Not Equal that(%v)", this.Address, that1.Address)
	}
	if !bytes.Equal(this.PubKey, that1.PubKey) {
		return fmt.Errorf("PubKey this(%v) Not Equal that(%v)", this.PubKey, that1.PubKey)
	}
	return nil
}
func (this *DataProvider) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*DataProvider)
	if !ok {
		that2, ok := that.(DataProvider)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !bytes.Equal(this.Address, that1.Address) {
		return false
	}
	if !bytes.Equal(this.PubKey, that1.PubKey) {
		return false
	}
	return true
}
func (this *MsgModuleOwner) VerboseEqual(that interface{}) error {
	if that == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that == nil && this != nil")
	}

	that1, ok := that.(*MsgModuleOwner)
	if !ok {
		that2, ok := that.(MsgModuleOwner)
		if ok {
			that1 = &that2
		} else {
			return fmt.Errorf("that is not of type *MsgModuleOwner")
		}
	}
	if that1 == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that is type *MsgModuleOwner but is nil && this != nil")
	} else if this == nil {
		return fmt.Errorf("that is type *MsgModuleOwner but is not nil && this == nil")
	}
	if !bytes.Equal(this.Address, that1.Address) {
		return fmt.Errorf("Address this(%v) Not Equal that(%v)", this.Address, that1.Address)
	}
	if !bytes.Equal(this.PubKey, that1.PubKey) {
		return fmt.Errorf("PubKey this(%v) Not Equal that(%v)", this.PubKey, that1.PubKey)
	}
	if !bytes.Equal(this.AssignerAddress, that1.AssignerAddress) {
		return fmt.Errorf("AssignerAddress this(%v) Not Equal that(%v)", this.AssignerAddress, that1.AssignerAddress)
	}
	return nil
}
func (this *MsgModuleOwner) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*MsgModuleOwner)
	if !ok {
		that2, ok := that.(MsgModuleOwner)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !bytes.Equal(this.Address, that1.Address) {
		return false
	}
	if !bytes.Equal(this.PubKey, that1.PubKey) {
		return false
	}
	if !bytes.Equal(this.AssignerAddress, that1.AssignerAddress) {
		return false
	}
	return true
}
func (this *OCRAbiEncoded) VerboseEqual(that interface{}) error {
	if that == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that == nil && this != nil")
	}

	that1, ok := that.(*OCRAbiEncoded)
	if !ok {
		that2, ok := that.(OCRAbiEncoded)
		if ok {
			that1 = &that2
		} else {
			return fmt.Errorf("that is not of type *OCRAbiEncoded")
		}
	}
	if that1 == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that is type *OCRAbiEncoded but is nil && this != nil")
	} else if this == nil {
		return fmt.Errorf("that is type *OCRAbiEncoded but is not nil && this == nil")
	}
	if !bytes.Equal(this.Context, that1.Context) {
		return fmt.Errorf("Context this(%v) Not Equal that(%v)", this.Context, that1.Context)
	}
	if !bytes.Equal(this.Oracles, that1.Oracles) {
		return fmt.Errorf("Oracles this(%v) Not Equal that(%v)", this.Oracles, that1.Oracles)
	}
	if len(this.Observations) != len(that1.Observations) {
		return fmt.Errorf("Observations this(%v) Not Equal that(%v)", len(this.Observations), len(that1.Observations))
	}
	for i := range this.Observations {
		if !this.Observations[i].Equal(that1.Observations[i]) {
			return fmt.Errorf("Observations this[%v](%v) Not Equal that[%v](%v)", i, this.Observations[i], i, that1.Observations[i])
		}
	}
	return nil
}
func (this *OCRAbiEncoded) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*OCRAbiEncoded)
	if !ok {
		that2, ok := that.(OCRAbiEncoded)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !bytes.Equal(this.Context, that1.Context) {
		return false
	}
	if !bytes.Equal(this.Oracles, that1.Oracles) {
		return false
	}
	if len(this.Observations) != len(that1.Observations) {
		return false
	}
	for i := range this.Observations {
		if !this.Observations[i].Equal(that1.Observations[i]) {
			return false
		}
	}
	return true
}
func (this *Observation) VerboseEqual(that interface{}) error {
	if that == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that == nil && this != nil")
	}

	that1, ok := that.(*Observation)
	if !ok {
		that2, ok := that.(Observation)
		if ok {
			that1 = &that2
		} else {
			return fmt.Errorf("that is not of type *Observation")
		}
	}
	if that1 == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that is type *Observation but is nil && this != nil")
	} else if this == nil {
		return fmt.Errorf("that is type *Observation but is not nil && this == nil")
	}
	if !bytes.Equal(this.Data, that1.Data) {
		return fmt.Errorf("Data this(%v) Not Equal that(%v)", this.Data, that1.Data)
	}
	return nil
}
func (this *Observation) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*Observation)
	if !ok {
		that2, ok := that.(Observation)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !bytes.Equal(this.Data, that1.Data) {
		return false
	}
	return true
}
func (this *FeedRewardSchema) VerboseEqual(that interface{}) error {
	if that == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that == nil && this != nil")
	}

	that1, ok := that.(*FeedRewardSchema)
	if !ok {
		that2, ok := that.(FeedRewardSchema)
		if ok {
			that1 = &that2
		} else {
			return fmt.Errorf("that is not of type *FeedRewardSchema")
		}
	}
	if that1 == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that is type *FeedRewardSchema but is nil && this != nil")
	} else if this == nil {
		return fmt.Errorf("that is type *FeedRewardSchema but is not nil && this == nil")
	}
	if this.Amount != that1.Amount {
		return fmt.Errorf("Amount this(%v) Not Equal that(%v)", this.Amount, that1.Amount)
	}
	if this.Strategy != that1.Strategy {
		return fmt.Errorf("Strategy this(%v) Not Equal that(%v)", this.Strategy, that1.Strategy)
	}
	return nil
}
func (this *FeedRewardSchema) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*FeedRewardSchema)
	if !ok {
		that2, ok := that.(FeedRewardSchema)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Amount != that1.Amount {
		return false
	}
	if this.Strategy != that1.Strategy {
		return false
	}
	return true
}
func (m *DataProvider) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DataProvider) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DataProvider) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.PubKey) > 0 {
		i -= len(m.PubKey)
		copy(dAtA[i:], m.PubKey)
		i = encodeVarintPrices(dAtA, i, uint64(len(m.PubKey)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Address) > 0 {
		i -= len(m.Address)
		copy(dAtA[i:], m.Address)
		i = encodeVarintPrices(dAtA, i, uint64(len(m.Address)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *MsgModuleOwner) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgModuleOwner) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgModuleOwner) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.AssignerAddress) > 0 {
		i -= len(m.AssignerAddress)
		copy(dAtA[i:], m.AssignerAddress)
		i = encodeVarintPrices(dAtA, i, uint64(len(m.AssignerAddress)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.PubKey) > 0 {
		i -= len(m.PubKey)
		copy(dAtA[i:], m.PubKey)
		i = encodeVarintPrices(dAtA, i, uint64(len(m.PubKey)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Address) > 0 {
		i -= len(m.Address)
		copy(dAtA[i:], m.Address)
		i = encodeVarintPrices(dAtA, i, uint64(len(m.Address)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *OCRAbiEncoded) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *OCRAbiEncoded) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *OCRAbiEncoded) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Observations) > 0 {
		for iNdEx := len(m.Observations) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Observations[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintPrices(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x1a
		}
	}
	if len(m.Oracles) > 0 {
		i -= len(m.Oracles)
		copy(dAtA[i:], m.Oracles)
		i = encodeVarintPrices(dAtA, i, uint64(len(m.Oracles)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Context) > 0 {
		i -= len(m.Context)
		copy(dAtA[i:], m.Context)
		i = encodeVarintPrices(dAtA, i, uint64(len(m.Context)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *Observation) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Observation) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Observation) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Data) > 0 {
		i -= len(m.Data)
		copy(dAtA[i:], m.Data)
		i = encodeVarintPrices(dAtA, i, uint64(len(m.Data)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *FeedRewardSchema) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *FeedRewardSchema) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *FeedRewardSchema) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Strategy) > 0 {
		i -= len(m.Strategy)
		copy(dAtA[i:], m.Strategy)
		i = encodeVarintPrices(dAtA, i, uint64(len(m.Strategy)))
		i--
		dAtA[i] = 0x12
	}
	if m.Amount != 0 {
		i = encodeVarintPrices(dAtA, i, uint64(m.Amount))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func encodeVarintPrices(dAtA []byte, offset int, v uint64) int {
	offset -= sovPrices(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *DataProvider) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Address)
	if l > 0 {
		n += 1 + l + sovPrices(uint64(l))
	}
	l = len(m.PubKey)
	if l > 0 {
		n += 1 + l + sovPrices(uint64(l))
	}
	return n
}

func (m *MsgModuleOwner) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Address)
	if l > 0 {
		n += 1 + l + sovPrices(uint64(l))
	}
	l = len(m.PubKey)
	if l > 0 {
		n += 1 + l + sovPrices(uint64(l))
	}
	l = len(m.AssignerAddress)
	if l > 0 {
		n += 1 + l + sovPrices(uint64(l))
	}
	return n
}

func (m *OCRAbiEncoded) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Context)
	if l > 0 {
		n += 1 + l + sovPrices(uint64(l))
	}
	l = len(m.Oracles)
	if l > 0 {
		n += 1 + l + sovPrices(uint64(l))
	}
	if len(m.Observations) > 0 {
		for _, e := range m.Observations {
			l = e.Size()
			n += 1 + l + sovPrices(uint64(l))
		}
	}
	return n
}

func (m *Observation) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Data)
	if l > 0 {
		n += 1 + l + sovPrices(uint64(l))
	}
	return n
}

func (m *FeedRewardSchema) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Amount != 0 {
		n += 1 + sovPrices(uint64(m.Amount))
	}
	l = len(m.Strategy)
	if l > 0 {
		n += 1 + l + sovPrices(uint64(l))
	}
	return n
}

func sovPrices(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozPrices(x uint64) (n int) {
	return sovPrices(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *DataProvider) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPrices
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DataProvider: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DataProvider: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Address", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPrices
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthPrices
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthPrices
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Address = append(m.Address[:0], dAtA[iNdEx:postIndex]...)
			if m.Address == nil {
				m.Address = []byte{}
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PubKey", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPrices
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthPrices
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthPrices
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PubKey = append(m.PubKey[:0], dAtA[iNdEx:postIndex]...)
			if m.PubKey == nil {
				m.PubKey = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPrices(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPrices
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgModuleOwner) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPrices
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgModuleOwner: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgModuleOwner: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Address", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPrices
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthPrices
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthPrices
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Address = append(m.Address[:0], dAtA[iNdEx:postIndex]...)
			if m.Address == nil {
				m.Address = []byte{}
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PubKey", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPrices
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthPrices
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthPrices
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PubKey = append(m.PubKey[:0], dAtA[iNdEx:postIndex]...)
			if m.PubKey == nil {
				m.PubKey = []byte{}
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AssignerAddress", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPrices
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthPrices
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthPrices
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AssignerAddress = append(m.AssignerAddress[:0], dAtA[iNdEx:postIndex]...)
			if m.AssignerAddress == nil {
				m.AssignerAddress = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPrices(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPrices
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *OCRAbiEncoded) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPrices
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: OCRAbiEncoded: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: OCRAbiEncoded: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Context", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPrices
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthPrices
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthPrices
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Context = append(m.Context[:0], dAtA[iNdEx:postIndex]...)
			if m.Context == nil {
				m.Context = []byte{}
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Oracles", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPrices
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthPrices
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthPrices
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Oracles = append(m.Oracles[:0], dAtA[iNdEx:postIndex]...)
			if m.Oracles == nil {
				m.Oracles = []byte{}
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Observations", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPrices
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPrices
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPrices
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Observations = append(m.Observations, &Observation{})
			if err := m.Observations[len(m.Observations)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPrices(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPrices
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Observation) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPrices
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Observation: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Observation: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Data", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPrices
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthPrices
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthPrices
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Data = append(m.Data[:0], dAtA[iNdEx:postIndex]...)
			if m.Data == nil {
				m.Data = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPrices(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPrices
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *FeedRewardSchema) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPrices
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: FeedRewardSchema: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: FeedRewardSchema: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Amount", wireType)
			}
			m.Amount = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPrices
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Amount |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Strategy", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPrices
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPrices
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPrices
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Strategy = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPrices(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPrices
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipPrices(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowPrices
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowPrices
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowPrices
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthPrices
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupPrices
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthPrices
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthPrices        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowPrices          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupPrices = fmt.Errorf("proto: unexpected end of group")
)
